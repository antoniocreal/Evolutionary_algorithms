# Given a target string, the goal is to produce target string starting from a random string of the same length. In the following implementation, following analogies are made â€“ 

# Characters A-Z, a-z, 0-9, and other special symbols are considered as genes
# A string generated by these characters is considered as chromosome/solution/Individual
# Fitness score is the number of characters which differ from characters in target string at a particular index. So individual having lower fitness value is given more preference.  

import numpy as np

# Define parameters
population_size = 100
chromosome_length = 100
mutation_rate = 0.25
num_generations = 1000
num_parents = int(min(population_size, population_size *0.1))  # Ensure even number of parents and do not exceed population size


# Initialize population
population = np.random.randint(2, size=(population_size, chromosome_length))

def fitness_function(chromosome):
    return np.sum(chromosome)

best_individual_idx = np.argmax(np.apply_along_axis(fitness_function, 1, population))
best_individual = population[best_individual_idx]
best_fitness = fitness_function(best_individual)

best_fitness_every_generation = []
best_fitness_ever = best_fitness

print("Best solution:", best_individual)
print("Best fitness:", best_fitness)

# Genetic Algorithm
for generation in range(num_generations):

    # Defining previous best solutions
    previous_best_individual_idx = best_individual_idx
    previous_best_individual = best_individual
    previous_best_fitness = best_fitness

    # Evaluate fitness
    fitness_values = np.apply_along_axis(fitness_function, 1, population)
    
    parents_indices = np.random.choice(range(population_size), size=num_parents, replace=False)

    parents = population[parents_indices]
    
    # Reshape parents array to ensure it has 3D structure
    parents = parents.reshape(-1, 2, chromosome_length)

    # Initialize empty offspring array
    offspring = np.empty((0, chromosome_length))

    
    # Perform multiple crossovers until desired number of offspring is reached
    while len(offspring) < population_size:
        # Perform crossover (single-point crossover)
        crossover_point = np.random.randint(1, chromosome_length)

        offspring_batch = np.concatenate((parents[:, 0, :crossover_point], parents[:, 1, crossover_point:]), axis=1)

        
        # Add offspring to the array
        offspring = np.concatenate((offspring, offspring_batch), axis=0)

    
    # Truncate excess offspring if more than population size
    offspring = offspring[:population_size]

    # Perform mutation
    mutation_mask = np.random.random(offspring.shape) < mutation_rate

    offspring[mutation_mask] = np.random.randint(2, size=np.count_nonzero(mutation_mask))
    
    # Replace old population with offspring
    population = offspring
    
    best_individual_idx = np.argmax(np.apply_along_axis(fitness_function, 1, population))
    best_individual = population[best_individual_idx]
    best_fitness = fitness_function(best_individual)
    best_fitness_every_generation.append(best_fitness)
    best_fitness_ever = max(best_fitness_every_generation)

    if best_fitness > previous_best_fitness:
        print("Best solution:", best_individual)
        print("Best fitness:", best_fitness)
        print('Best fitness ever:', best_fitness_ever)

    # print(f'\nFinish iteration: {generation}')

# Find best individual in final population
best_individual_idx = np.argmax(np.apply_along_axis(fitness_function, 1, population))
best_individual = population[best_individual_idx]
best_fitness = fitness_function(best_individual)
best_fitness_every_generation.append(best_fitness)
best_fitness_ever = max(best_fitness_every_generation)

print("Best solution:", best_individual)
print("Best fitness:", best_fitness)
print('Best fitness ever:', best_fitness_ever)
print('Every best fitness of every generation',best_fitness_every_generation)